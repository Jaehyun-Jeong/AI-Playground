from typing import Type
import numpy as np


class Node:

    def __init__(
        self,
        feature: int = None,  # 피처의 인덱스, Branch 노드면 필요
        threshold: float = None,  # 임계값, Branch 노드면 필요
        classIdx: int = None  # 분류할 클래스, Leaf 노드면 필요
    ):

        Type[Node]: self.__left = None  # 왼쪽 노드
        Type[Node]: self.__right = None  # 오른쪽 노드

        # Branch 노드를 위한 인스턴스
        self.feature: int = feature
        self.threshold: float = threshold

        # Leaf 노드를 위한 인스턴스
        self.classIdx: int = classIdx

    @property
    def left(self):
        return self.__left

    @left.setter
    def left(self, node):
        self.__left = node

    @property
    def right(self):
        return self.__right

    @right.setter
    def right(self, node):
        self.__right = node

    # Leaf 노드인지, Branch 노드인지 확인
    def is_leaf(self) -> bool:
        return False if self.classIdx is None else True


class DecisionTree():

    def __init__(
        self,
    ):

        self._numFeatures: int = None
        self._root: Type(Node) = None  # Root 노드

    def train(
        self,
        X: np.ndarray,
        Y: np.ndarray
        ):

        pass

    def __build_tree(
        self,
        X: np.ndarray,
        Y: np.ndarray
    ):
        classes = np.unique(Y)
        featureIdxs = [i for i in range(self.numFeatures)]
        featureIdx, threshold = \
            self.__best_criteria(X, Y, featureIdxs)

        # End building Tree
        if len(classes) == 1:  # End condition
            # Return leaf node
            return Node(classIdx=self.select_class(Y))

        leftIdxs, rightIdxs = self.__split(X, featureIdx, threshold)

        left = self.__build_tree(X[leftIdxs, :], Y[leftIdxs])
        right = self.__build_tree(X[rightIdxs, :], Y[rightIdxs])

        # Create root node
        node = Node(feature=featureIdx, threshold=threshold)
        node.left = left
        node.right = right

        # Return root node
        return node

    def __best_criteria(
        self,
        X: np.ndarray,
        Y: np.ndarray,
        featureIdxs: list
    ):

        bestFeature: int = None
        bestThreshold: float = None
        giniImpurity: float = None
        bestGiniImpurity: float = 1  # 1 means worst gini impurity
        size: int = len(Y)

        for featureIdx in featureIdxs:
            XFeature = X[:, featureIdx]
            thresholds = np.unique(XFeature)
            for threshold in thresholds:
                leftIdxs, rightIdxs = \
                    self.__split(X, featureIdx, threshold)
                leftGiniImpurity = self.gini_impurity(Y[leftIdxs])
                rightGiniImpurity = self.gini_impurity(Y[rightIdxs])

                # Weighted gini impurity
                sizeLeft = len(leftIdxs)
                sizeRight = len(rightIdxs)
                giniImpurity = 0
                giniImpurity += \
                    leftGiniImpurity * sizeLeft / size
                giniImpurity += \
                    rightGiniImpurity * sizeRight / size

                # The smaller the better
                if bestGiniImpurity > giniImpurity:
                    bestGiniImpurity = giniImpurity
                    bestFeature = featureIdx
                    bestThreshold = threshold

        return bestFeature, bestThreshold

    @staticmethod
    def __select_class(
        Y: np.ndarray
    ):

        return np.bincount(Y).argmax()

    @staticmethod
    def __split(
        X: np.ndarray,
        featureIdx: int,
        threshold: float
    ):

        XFeature = X[: featureIdx]
        leftIdxs = np.argwhere(XFeature <= threshold).flatten()
        rightIdxs = np.argwhere(XFeature > threshold).flatten()

        return leftIdxs, rightIdxs

    @staticmethod
    def gini_impurity(
        Y: np.ndarray
    ) -> float:

        giniImpurity: float = 1
        listClasses: np.ndarray = np.unique(Y)
        sizeY: int = len(Y)

        for classIdx in listClasses:
            giniImpurity -= (np.sum(Y == classIdx) / sizeY)**2

        return giniImpurity


if __name__ == "__main__":

    from pandas import read_csv

    # Load Data
    df = read_csv("../Datasets/diamond_rock_index.csv")

    X = df[['hardness', 'brightness']].to_numpy()
    Y = df['sort'].to_numpy()

    DT = DecisionTree(1)
    print(DT.best_criteria(X, Y, [0, 1]))
